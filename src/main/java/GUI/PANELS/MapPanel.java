/**
 * Projekt do předmětu PDB (2016/2017) - Prostorové, multimediální a temporální 
 * databáze: Metro Accident Databse
 * Autoři: Petr Staněk (xstane34), 
           František Matečný (xmatec00),
           Jakub Stejskal (xstejs24)
 * Datum:  12.12.2016
 * Verze:  1.0
 */
package GUI.PANELS;

import GUI.WINDOW.ObjectName;
import GUI.WINDOW.ObjectChange;
import DB.Objects.DrawPolygon;
import DB.Objects.DrawRectangle;
import DB.Objects.DrawPoint;
import DB.Queries.Spatial;
import DB.ScriptRunner;
import GUI.Main;
import GUI.WINDOW.DeleteQuestion;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.event.KeyEvent;
import static java.awt.event.MouseEvent.BUTTON1;
import static java.awt.event.MouseEvent.BUTTON3;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import static java.lang.Math.abs;


/**
 * Třída panelu s mapou.
 */
public class MapPanel extends javax.swing.JPanel {

    private ObjectName miniPanel;
    private ObjectChange changePanel;
    private DeleteQuestion deletePanel;
    
    private int x1 = 0;
    private int y1 = 0;
    private int x2 = 0;
    private int y2 = 0;
    private int rectX = 0;
    private int rectY = 0;
    private int rectWidth = 0;
    private int rectHeight = 0;
    
    private int activeIndexPoints = -1;
    
    private List<DrawPoint> listPoints;
    private List<DrawRectangle> listRectangles;
    private List<DrawPolygon> listPolylines;
    private List<DrawPolygon> listPolygons;
    
    private boolean dragged = false;
    private boolean moved = false;
    private boolean drawPolygon = false;
    private boolean drawPolyline = false;
    public boolean editMode = false;
    
    public Color lineColor;
    public Color circuitColor;
    public Color stationColor;
    
    public enum ObjectType {
            POINT, LINE, RECT, POLYGON}
    
    public ObjectType oType = null;
    
    /**
     * Creates new form MapPanel
     * @throws java.lang.Exception
     */
    public MapPanel() throws Exception {
        initComponents();
        
        listPoints = Main.spacialObjects.listPoints;
        listRectangles =  Main.spacialObjects.listRectangles;
        listPolylines =  Main.spacialObjects.listPolylines;
        listPolygons = Main.spacialObjects.listPolygons;       
       
        miniPanel = new ObjectName(Main.TopLevelWindow, true);
        changePanel = new ObjectChange(Main.TopLevelWindow, true);
        deletePanel = new DeleteQuestion(Main.TopLevelWindow, true);     
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setPreferredSize(new java.awt.Dimension(600, 400));
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                formKeyReleased(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 525, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 403, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        if (oType == ObjectType.RECT){
            x1 = evt.getX();
            y1 = evt.getY();
        }
        
        if (editMode){
            x1 = evt.getX();
            y1 = evt.getY();
            if (getActiveLine() != null){
                activeIndexPoints = getActiveLineIndexPoints(getActiveLine());}
            else if(getActivePolygon() != null){
                activeIndexPoints = getActiveLineIndexPoints(getActivePolygon());
            }
            else if(getActiveRectangle()!= null){
                rectX = getActiveRectangle().x;
                rectY = getActiveRectangle().y;
                rectWidth = getActiveRectangle().width;
                rectHeight = getActiveRectangle().height;
            }
        }
        
    }//GEN-LAST:event_formMousePressed
	
	/**
	 * Ovládání mapy myší - uvolnění myši.
	 * @param evt předaná událost
	 */
    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
      
        if (oType == ObjectType.RECT){
            dragged = false;
            x2 = evt.getX();
            y2 = evt.getY();
            listRectangles.add(new DrawRectangle(x1 > x2 ? x2 : x1, y1 > y2 ? y2 : y1, abs(x2-x1), abs(y2-y1)));
            listRectangles.get(listRectangles.size()-1).color = circuitColor;
            repaint();
            miniPanel.setVisible(true);
            if (miniPanel.name.isEmpty() && !listRectangles.isEmpty()){
                listRectangles.remove(listRectangles.size()-1);
                repaint();
                }
            else {
                listRectangles.get(listRectangles.size()-1).name = miniPanel.name;
                DB.Queries.Spatial.insertCircuitToDB(null, listRectangles.get(listRectangles.size()-1));
            }
            
        }
    }//GEN-LAST:event_formMouseReleased

	/**
	 * Ovládání mapy myší - přesun myši.
	 * @param evt předaná událost
	 */
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        if (oType == ObjectType.RECT){
            dragged = true;
            x2 = evt.getX();
            y2 = evt.getY();
            repaint();
        }
        
        if (editMode){
            x1 = evt.getX();
            y1 = evt.getY();
            if (getActivePoint() != null){
                getActivePoint().geometryChanged = true;
                getActivePoint().p2d.setLocation(x1, y1);
                repaint();
            } else if (getActiveLine() != null && activeIndexPoints != -1) {
                getActiveLine().geometryChanged = true;
                getActiveLine().xpoints[activeIndexPoints] = x1;
                getActiveLine().ypoints[activeIndexPoints] = y1;
                repaint();
            }
            else if(getActivePolygon() != null && activeIndexPoints != -1) {
                getActivePolygon().geometryChanged = true;
                getActivePolygon().xpoints[activeIndexPoints] = x1;
                getActivePolygon().ypoints[activeIndexPoints] = y1;
                repaint();
            }
            else if(getActiveRectangle() != null){
                DrawRectangle p = getActiveRectangle();
                if(x1 < p.x+8 && x1 > p.x-8 && y1 < p.y+8 && y1 > p.y-8) {
                    p.geometryChanged = true;
                    p.width = rectWidth + (rectX-x1);
                    p.height = rectHeight + (rectY-y1);
                    p.x = x1;
                    p.y = y1;
                } else if(x1 < p.x+8 && x1 > p.x-8 && y1 < p.y+p.height+8 && y1 > p.y+p.height-8) {
                    p.geometryChanged = true;
                    p.width = rectWidth + (rectX-x1);
                    p.height = (y1-rectY);
                    p.x = x1;
                } else if(x1 < p.x+p.width+8 && x1 > p.x+p.width-8 && y1 < p.y+p.height+8 && y1 > p.y+p.height-8) {
                    p.geometryChanged = true;
                    p.width = abs(p.x-x1);
                    p.height = abs(p.y-y1);
                } else if(x1 < p.x+p.width+8 && x1 > p.x+p.width-8 && y1 < p.y+8 && y1 > p.y-8) {
                    p.geometryChanged = true;
                    p.width = (x1-rectX);
                    p.height = rectHeight + (rectY-y1);
                    p.y = y1;
                }
                repaint();
            }
        }
        
    }//GEN-LAST:event_formMouseDragged
	
	/**
	 * Ovládání mapy myší - stisknutí myši.
	 * @param evt předaná událost
	 */
    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        if (editMode){
            oType = null;
            x1 = evt.getX();
            y1 = evt.getY();
            try {
            editMode(evt.getClickCount());
            } catch (Exception ex) {Logger.getLogger(MapPanel.class.getName()).log(Level.SEVERE, null, ex);}
        }
        else {
        if (oType == ObjectType.POINT){
            x1 = evt.getX();
            y1 = evt.getY();
            if(isClickedOnLine()){
                listPoints.add(new DrawPoint(x1, y1));
                listPoints.get(listPoints.size()-1).color = stationColor;
                repaint();
                miniPanel.setVisible(true);
                if (miniPanel.name.isEmpty() && !listPoints.isEmpty()){
                    listPoints.remove(listPoints.size()-1);
                    repaint();
                    } else {
                        listPoints.get(listPoints.size()-1).name = miniPanel.name;
                        DB.Queries.Spatial.insertStationToDB(listPoints.get(listPoints.size()-1));
                    }
            }
        }
        
        if (oType == ObjectType.LINE){
            if (evt.getButton() == BUTTON1){
                x1 = evt.getX();
                y1 = evt.getY();
                if (listPolylines.isEmpty() || !drawPolyline){
                    listPolylines.add(new DrawPolygon());
                    drawPolyline = true;
				}
                listPolylines.get(listPolylines.size()-1).addPoint(x1, y1);
                listPolylines.get(listPolylines.size()-1).color = lineColor;
                repaint();
            }
            
            if (evt.getButton() == BUTTON3 && drawPolyline){
                moved = false;
                drawPolyline = false;
                if (listPolylines.get(listPolylines.size()-1).npoints < 2){
                    listPolylines.remove(listPolylines.size()-1);
                    repaint();
                    return;
                }
                repaint();
                miniPanel.setVisible(true);
                if (miniPanel.name.isEmpty() && !listPolylines.isEmpty()){
                    listPolylines.remove(listPolylines.size()-1);
                    repaint();
				}
                else {
                    listPolylines.get(listPolylines.size()-1).name = miniPanel.name;
                    	DB.Queries.Spatial.insertLineToDB(listPolylines.get(listPolylines.size()-1));
                }
            }
        }
 
        if (oType == ObjectType.POLYGON){
            if (evt.getButton() == BUTTON1){
                x1 = evt.getX();
                y1 = evt.getY();
                if (listPolygons.isEmpty() || !drawPolygon){
                    listPolygons.add(new DrawPolygon());
                    drawPolygon = true;
				}

                listPolygons.get(listPolygons.size()-1).addPoint(x1, y1);
                listPolygons.get(listPolygons.size()-1).color = circuitColor;
                repaint();
            }
            
            if (evt.getButton() == BUTTON3){
                moved = false;
                drawPolygon = false;   
                repaint();
                miniPanel.setVisible(true);
                if (miniPanel.name.isEmpty() && !listPolygons.isEmpty()){
                    listPolygons.remove(listPolygons.size()-1);
                    repaint();
                    }
                else {
                    listPolygons.get(listPolygons.size()-1).name = miniPanel.name;
                    	DB.Queries.Spatial.insertCircuitToDB(listPolygons.get(listPolygons.size()-1), null);
                }
            }
        }
        }
    }//GEN-LAST:event_formMouseClicked
	
	/**
	 * Ovládání mapy myší - posun myši.
	 * @param evt předaná událost
	 */
    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        if ((oType == ObjectType.POLYGON &&  drawPolygon) ||
            (oType == ObjectType.LINE &&  drawPolyline)){
            moved = true;
            x2 = evt.getX();
            y2 = evt.getY();
            repaint();
        }
    }//GEN-LAST:event_formMouseMoved
	
	/**
	 * Ovládání mapy myší - stisknutí tlačítka ve formuláři.
	 * @param evt předaná událost
	 */
    private void formKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyReleased

        if(editMode && evt.getKeyCode()== KeyEvent.VK_DELETE){
            deleteActiveObject();
        }
    }//GEN-LAST:event_formKeyReleased

	/**
	 * Úprava komonent mapy v režimu mapy.
	 * @param click rozlišení kliku
	 * @throws Exception výjimka
	 */
    private void editMode(int click) throws Exception{
        setActiveFalse();
        for (DrawPoint p : listPoints) {
            if(x1 < p.p2d.getX()+5 && x1 > p.p2d.getX()-5 && y1 < p.p2d.getY()+5 && y1 > p.p2d.getY()-5){
//                System.out.println("klikam na stanicu: " + p.name);
                p.active = true;
                if (click == 2) {
                    changePanel.setVariable(p.name, p.color);
                    changePanel.setVisible(true);
                    if (!changePanel.name.equals(p.name) || !Color.decode(changePanel.color).equals(p.color)){
                        p.name = changePanel.name;
                        p.color = Color.decode(changePanel.color);
                        Spatial.UpdateStationToDB(p);
                    } 
                }
                repaint();
                return;
            }
        }
  
        for (DrawPolygon p : listPolylines) {   
            if((p.intersects(x1-1, y1-1, 3, 3)) && 
               (!p.intersects(x1-3, y1-3, 1, 1) || 
                !p.intersects(x1+3, y1+3, 1, 1) || 
                !p.intersects(x1+3, y1-3, 1, 1) || 
                !p.intersects(x1-3, y1+3, 1, 1))){
//                System.out.println("klikam na linku: " + p.name);
                p.active = true;
                if (click == 2) {
                    changePanel.setVariable(p.name, p.color);;
                    changePanel.setVisible(true);
                    if (!changePanel.name.equals(p.name) || !Color.decode(changePanel.color).equals(p.color)){
                        p.name = changePanel.name;
                        p.color = Color.decode(changePanel.color);
                        Spatial.UpdateLineToDB(p);
                    }
                }
                repaint();
                return;
            }
        }
        
        for (DrawRectangle p : listRectangles) {   
            if((p.intersects(x1-1, y1-1, 3, 3)) && 
               (!p.intersects(x1-3, y1-3, 1, 1) || 
                !p.intersects(x1+3, y1+3, 1, 1) || 
                !p.intersects(x1+3, y1-3, 1, 1) || 
                !p.intersects(x1-3, y1+3, 1, 1))){
//                System.out.println("klikam na obvod: " + p.name);
                p.active = true;
                if (click == 2) {
                    changePanel.setVariable(p.name, p.color);
                    changePanel.setVisible(true);
                    if (!changePanel.name.equals(p.name) || !Color.decode(changePanel.color).equals(p.color)){
                        p.name = changePanel.name;
                        p.color = Color.decode(changePanel.color);
                        Spatial.UpdateCircuitToDB(null, p);
                    }
                }
                repaint();
                return;
            }
        }
        
        for (DrawPolygon p : listPolygons) {   
            if((p.intersects(x1-1, y1-1, 3, 3)) && 
               (!p.intersects(x1-3, y1-3, 1, 1) || 
                !p.intersects(x1+3, y1+3, 1, 1) || 
                !p.intersects(x1+3, y1-3, 1, 1) || 
                !p.intersects(x1-3, y1+3, 1, 1))){
//                System.out.println("klikam na obvod: " + p.name);
                p.active = true;
                if (click == 2) {
                    changePanel.setVariable(p.name, p.color);
                    changePanel.setVisible(true);
                    if (!changePanel.name.equals(p.name) || !Color.decode(changePanel.color).equals(p.color)){
                        p.name = changePanel.name;
                        p.color = Color.decode(changePanel.color);
                        Spatial.UpdateCircuitToDB(p, null);
                    }
                }
                repaint();
                return;
            }
        }
    
    }
    
    @Override
    public void paintComponent(Graphics gg) {
        super.paintComponent(gg); // fixes the immediate problem.
        Graphics2D g = (Graphics2D) gg;
        g.setStroke(new BasicStroke(3)); //line width
            //polygony
        if (!listPolygons.isEmpty()){
            if (moved && drawPolygon){
                Polygon p = listPolygons.get(listPolygons.size()-1);
                g.drawPolyline(p.xpoints, p.ypoints, p.npoints);
                
                g.drawLine(listPolygons.get(listPolygons.size()-1).xpoints[listPolygons.get(listPolygons.size()-1).npoints-1],
                            listPolygons.get(listPolygons.size()-1).ypoints[listPolygons.get(listPolygons.size()-1).npoints-1],
                            x2, y2);
            }
            
            for (int i = 0; i < listPolygons.size()-1; i++) {
                g.setPaint(listPolygons.get(i).color);
                g.drawPolygon(listPolygons.get(i).xpoints, listPolygons.get(i).ypoints, listPolygons.get(i).npoints);
                if (listPolygons.get(i).active){
                    g.setStroke(new BasicStroke(1));
                    g.setPaint(Color.BLACK);
                    g.drawString(listPolygons.get(i).name,x1, y1);
                    for (int j = 0; j < listPolygons.get(i).npoints; j++) {
                        g.setStroke(new BasicStroke(1));
                        g.setPaint(Color.BLACK);
                        g.drawOval(listPolygons.get(i).xpoints[j]-8, listPolygons.get(i).ypoints[j]-8, 16, 16);   
                    }
                    g.setStroke(new BasicStroke(3));
                }
            }

            if (!drawPolygon){
                g.setPaint(listPolygons.get(listPolygons.size()-1).color);
                g.drawPolygon(listPolygons.get(listPolygons.size()-1).xpoints, listPolygons.get(listPolygons.size()-1).ypoints, listPolygons.get(listPolygons.size()-1).npoints);
                if (listPolygons.get(listPolygons.size()-1).active){
                    g.setStroke(new BasicStroke(1));
                    g.setPaint(Color.BLACK);
                    g.drawString(listPolygons.get(listPolygons.size()-1).name, x1, y1);
                    for (int j = 0; j < listPolygons.get(listPolygons.size()-1).npoints; j++) {
                        g.drawOval(listPolygons.get(listPolygons.size()-1).xpoints[j]-8, listPolygons.get(listPolygons.size()-1).ypoints[j]-8, 16, 16);   
                    }
                    g.setStroke(new BasicStroke(3));
                }     
            }
        }
        
  
        for (DrawRectangle r : listRectangles) {
            g.setPaint(r.color);
            g.drawRect(r.x, r.y, r.width, r.height);
            if (r.active){
                g.setStroke(new BasicStroke(1));
                g.setPaint(Color.BLACK);
                g.drawString(r.name, x1, y1);
                g.drawOval(r.x-8, r.y-8, 16, 16);
                g.drawOval(r.x-8, r.y+r.height-8, 16, 16);
                g.drawOval(r.x+r.width-8, r.y+r.height-8, 16, 16);
                g.drawOval(r.x+r.width-8, r.y-8, 16, 16);
                g.setStroke(new BasicStroke(3));
            }
        }
        
        if (dragged && oType == ObjectType.RECT){
            g.setPaint(circuitColor);
            g.drawRect(x1 > x2 ? x2 : x1, y1 > y2 ? y2 : y1, abs(x2-x1), abs(y2-y1));
        }
            //polyline
        if (!listPolylines.isEmpty()){
            if (moved && drawPolyline){
                DrawPolygon p = listPolylines.get(listPolylines.size()-1);
                g.setPaint(p.color);
                g.drawPolyline(p.xpoints, p.ypoints, p.npoints);
                
                g.drawLine(p.xpoints[p.npoints-1], p.ypoints[p.npoints-1], x2, y2);
            }

            for (int i = 0; i < listPolylines.size()-1; i++) {
                g.setPaint(listPolylines.get(i).color);
                g.drawPolyline(listPolylines.get(i).xpoints, listPolylines.get(i).ypoints, listPolylines.get(i).npoints);
                if (listPolylines.get(i).active){
                    g.setStroke(new BasicStroke(1));
                    g.setPaint(Color.BLACK);
                    g.drawString(listPolylines.get(i).name, x1, y1);
                    for (int j = 0; j < listPolylines.get(i).npoints; j++) {
                        g.drawOval(listPolylines.get(i).xpoints[j]-8, listPolylines.get(i).ypoints[j]-8, 16, 16);
                    }
                    g.setStroke(new BasicStroke(3));
                }
            }

            if (!drawPolyline){
                g.setPaint(listPolylines.get(listPolylines.size()-1).color);
                g.drawPolyline(listPolylines.get(listPolylines.size()-1).xpoints, listPolylines.get(listPolylines.size()-1).ypoints, listPolylines.get(listPolylines.size()-1).npoints);
                if (listPolylines.get(listPolylines.size()-1).active){
                    for (int j = 0; j < listPolylines.get(listPolylines.size()-1).npoints; j++) {
                        g.setStroke(new BasicStroke(1));
                        g.setPaint(Color.BLACK);
                        g.drawOval(listPolylines.get(listPolylines.size()-1).xpoints[j]-8, listPolylines.get(listPolylines.size()-1).ypoints[j]-8, 16, 16);
                    }
                    g.setStroke(new BasicStroke(3));
                }
            }
        }

        for (DrawPoint p : listPoints) {
            g.setPaint(p.color);
            g.fillOval((int)p.p2d.getX()-4, (int) p.p2d.getY()-4, 8, 8);
            if (p.active){
                g.setStroke(new BasicStroke(1));
                g.setPaint(Color.BLACK);
                g.drawString(p.name, x1, y1);
                g.drawOval((int)p.p2d.getX()-8, (int) p.p2d.getY()-8, 16, 16);
                g.setStroke(new BasicStroke(3));
            }
        }
    }
    
	/**
	 * Ověření kliku na linku metra.
	 * @return true - kliknuto
	 */
    public boolean isClickedOnLine(){
        for (DrawPolygon p : listPolylines) { 
            if((p.intersects(x1-1, y1-1, 6, 6)) && 
               (!p.intersects(x1-6, y1-6, 1, 1) || 
                !p.intersects(x1+6, y1+6, 1, 1) || 
                !p.intersects(x1+6, y1-6, 1, 1) || 
                !p.intersects(x1-6, y1+6, 1, 1)))
                {
//                System.out.println("klikam stanicu na linku: " + p.name + "," + p.id);
                for(int i = 0; i< p.npoints-1;i++){
                    if ((x1 >= p.xpoints[i] && x1 <= p.xpoints[i+1] && //   |\
                        y1 >= p.ypoints[i] && y1 <= p.ypoints[i+1]) || 
                        (x1 >= p.xpoints[i] && x1 <= p.xpoints[i+1] &&  //  |/
                        y1 <= p.ypoints[i] && y1 >= p.ypoints[i+1]) ||
                        (x1 <= p.xpoints[i] && x1 >= p.xpoints[i+1] && //   \|
                        y1 <= p.ypoints[i] && y1 >= p.ypoints[i+1]) ||
                        (x1 <= p.xpoints[i] && x1 >= p.xpoints[i+1] &&  //  /|
                        y1 >= p.ypoints[i] && y1 <= p.ypoints[i+1]))
                    {
                        double k = ((double)(p.ypoints[i+1]-p.ypoints[i]))/((double)(p.xpoints[i+1]-p.xpoints[i]));
                        if (k > 100){
//                            System.out.println("fsa");
                            x1 = p.xpoints[i];
                            return true;
                        }
                        else{
//                        System.out.println(k);
                        int q = (int) (p.ypoints[i] - (k*p.xpoints[i]));
                        y1 = (int) (k*x1+q);
                        return true;}
                    }
                }
                }
            }
        return false;
    }
    
	/**
	 * Vrátí bod zvolený bod.
	 * @return bod
	 */
    public DrawPoint getActivePoint(){
        for (DrawPoint p : listPoints) {
            if(p.active){
            return p;}
        }
        return null;
    }
    
	/**
	 * Vrátí zvolenou linku.
	 * @return linka
	 */
    public DrawPolygon getActiveLine(){
        for (DrawPolygon p : listPolylines) {
            if(p.active){
               return p;}
        }
        return null;
    }
    
	/**
	 * Vrátí zvolený polygon.
	 * @return polygon
	 */
    public DrawPolygon getActivePolygon(){
        for (DrawPolygon p : listPolygons) {
            if(p.active){
               return p;
            }
        }
        return null;
    }
    
	/**
	 * Vrátí zvolečný čverec obvodu.
	 * @return čtverec
	 */
    public DrawRectangle getActiveRectangle(){
        for (DrawRectangle p : listRectangles) {
            if(p.active){
               return p;
            }
        }
        return null;
    }
    
    /**
	 * Vrátí zvolený index bodu na lince při posouvání.
	 * @param p  polygon
	 * @return index
	 */
    public int getActiveLineIndexPoints(DrawPolygon p){
    
        for (int i = 0; i < p.npoints; i++) {
            if(x1 < p.xpoints[i]+8 && x1 > p.xpoints[i]-8 && y1 < p.ypoints[i]+8 && y1 > p.ypoints[i]-8){
                return i;
            }
        }
        return -1;
    }
    
    /**
	 * Nastaví všechny všechny body na neaktivní.
	 */
    public void setActiveFalse() {
        for (DrawPoint p : listPoints) {
            p.active = false;
        }
        
        for (DrawPolygon p : listPolylines) {
            p.active = false;
        }
        
        for (DrawPolygon p : listPolygons) {
            p.active = false;
        }
        
        for (DrawRectangle p : listRectangles) {
            p.active = false;
        }   
        repaint();
    }
    
	/**
	 * Aktualizuje geometrií mapy.
	 * @throws Exception výjimka
	 */
    public void updateObjectsGeometry() throws Exception{
        for (DrawPoint listPoint : listPoints) {
            if(listPoint.geometryChanged){
                Spatial.UpdateStationGeometry(listPoint);
                listPoint.geometryChanged = false;}
        }
        
        for (DrawPolygon listPolyline : listPolylines) {
            if(listPolyline.geometryChanged){
                Spatial.UpdateLineGeometry(listPolyline);
                listPolyline.geometryChanged = false;}
        }
        
        for (DrawRectangle listRectangle : listRectangles) {
            if(listRectangle.geometryChanged){
                Spatial.UpdateCircuitGeometry(null, listRectangle);
                listRectangle.geometryChanged = false;}
        }
    
        for (DrawPolygon listPolygon : listPolygons) {
            if(listPolygon.geometryChanged){
                Spatial.UpdateCircuitGeometry(listPolygon, null);
                listPolygon.geometryChanged = false;}
        }    
    }
    
    /**
	 * Smaže zvolený objekt.
	 */
    public void deleteActiveObject(){
           DrawPoint p;
           DrawRectangle r;
           DrawPolygon l;
           
           p = getActivePoint();
           if (p != null){
                deletePanel.setVisible(true);
                if (deletePanel.answer){
                    Spatial.deleteStation(p.id);
                    listPoints.remove(p);
                    repaint();
                    return;}
           } 
           l = getActiveLine();
           if (l != null){
                deletePanel.setVisible(true);
                if (deletePanel.answer){
                    Spatial.deleteLine(l.id);
                    listPolylines.remove(l);
                    repaint();
                    return;}
           }
           r = getActiveRectangle();
           if (r != null){
               deletePanel.setVisible(true);
               if (deletePanel.answer){
                    Spatial.deleteCircuit(-1, r.id);
                    listRectangles.remove(r);
                    repaint();
                    return;}
           }
           l = getActivePolygon();
           if (l != null){
               deletePanel.setVisible(true);
               if (deletePanel.answer){
                    Spatial.deleteCircuit(l.id, -1);
                    listPolygons.remove(l);
                    repaint();
                    return;}
           }
    }
    
    /**
	 * Smaže celou mapu.
	 */
    public void deleteAllObject(){
        deletePanel.setText("Opravdu chcete smazat celou mapu?");
        deletePanel.setVisible(true);
        if (deletePanel.answer){
            oType = null;
            listPolylines.clear();
            listPoints.clear();
            listRectangles.clear();
            listPolygons.clear();
            Spatial.deleteDB();
            repaint();
        }
        deletePanel.setText("Opravdu chcete smazat komponentu?");
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
